/****************************************************************
  relative_me.h

  Construction of constant and kinematic (r^2 and k^2) relative
  operators.

  (The identity operator is provided in basis/lsjt_operator.h.)

  Note on oscillator length: Oscillator lengths for two-particle
  rel-cm coordinates are related to oscillator length for
  single-particle basis as:

    b_rel = 2^(1/2)*b
    b_cm = 2^(-1/2)*b

  The matrix elements generated by these routines are calculated for
  oscillator length parameter b_rel = 2^(1/2) in the relative
  coordinate, which, after Moshinsky transformation, yields matrix
  elements for two-body states built from single-particle wave
  functions with oscillator length parameter b=1.  However, in the
  actual calculations, we first calculate matrix element for relative
  b_rel=1, then analytically rescale to b_rel = 2^(1/2).  Matrix
  elements of r^n must scale by (b_rel/b)^n, and those for k^n must
  scale by (b_rel/b)^-n.  Thus, e.g., for Coulomb (n=-1) the scale
  factor is 1/sqrt(2.).

  See notes on "internal representation of an operator in JT
  scheme" in lsjt_operator.h for the general principles of how the
  operators are represented.

  Language: C++11
                                 
  Mark A. Caprio
  University of Notre Dame

  + 7/12/16 (mac): Created (as construct_relative).
  + 3/26/17 (mac): Add ConstructCoulombOperator.
  + 3/28/17 (mac):
    - Rename to relative_me.
    - Remove ConstructDiagonalConstantOperator.
  + 7/1/17 (mac): Add ConstructQuadrupoleOperator.
  + 10/19/17 (mac): Add scale factors for relative oscillator length.

****************************************************************/

#ifndef RELATIVE_ME_H_
#define RELATIVE_ME_H_

#include "basis/lsjt_operator.h"
#include "basis/proton_neutron.h"

namespace relative {

  enum class KinematicOperator {kKSqr,kRSqr};
  void ConstructKinematicOperator(
      const basis::OperatorLabelsJT& operator_labels,
      const basis::RelativeSpaceLSJT& relative_space,
      std::array<basis::RelativeSectorsLSJT,3>& relative_component_sectors,
      std::array<basis::OperatorBlocks<double>,3>& relative_component_matrices,
      relative::KinematicOperator kinematic_operator
    );
  // Construct simple "kinematic" (r^2 and k^2) operators in relative
  // LSJT basis.
  //
  // These matrix elements are calculated for oscillator length
  // parameter b_rel = 2^(1/2) in the relative coordinate.  (See "Note
  // on oscillator length" at start of this header file.)
  //
  // Makes use of analytic matrix elements for r^2 and k^2 in
  // oscillator basis.
  //
  // See notes on "internal representation of an operator in JT
  // scheme" in lsjt_operator.h for the general principles of how the
  // operators are represented.
  //
  // Arguments:
  //   operator_labels (input) : tensorial properties of operator
  //   relative_space (input) : target space
  //   relative_component_sectors (output) : target sectors
  //   relative_component_matrices (output) : target matrices
  //   kinematic_operator (input): whether to construct coordinate
  //     or momentum operator

  void ConstructQuadrupoleOperator(
      const basis::OperatorLabelsJT& operator_labels,
      const basis::RelativeSpaceLSJT& relative_space,
      std::array<basis::RelativeSectorsLSJT,3>& relative_component_sectors,
      std::array<basis::OperatorBlocks<double>,3>& relative_component_matrices,
      relative::KinematicOperator kinematic_operator,
      basis::OperatorTypePN operator_type
    );
  // Construct quadrupole operator in relative LSJT basis.
  //
  // These matrix elements are calculated for oscillator length
  // parameter b_rel = 2^(1/2) in the relative coordinate.  (See "Note
  // on oscillator length" at start of this header file.)
  //
  // Here the operator_type indicates protons/neutrons/both relative
  // to *total* center of mass.
  //
  // TODO: implement p and n operators
  //
  // Arguments:
  //   operator_labels (input) : tensorial properties of operator
  //   relative_space (input) : target space
  //   relative_component_sectors (output) : target sectors
  //   relative_component_matrices (output) : target matrices
  //   kinematic_operator (input): whether to construct coordinate
  //     or momentum operator (coopted from ConstructKinematicOperator)
  //   operator_type (input): operator for protons, neutrons, or both

  void ConstructCoulombOperator(
      const basis::OperatorLabelsJT& operator_labels,
      const basis::RelativeSpaceLSJT& relative_space,
      std::array<basis::RelativeSectorsLSJT,3>& relative_component_sectors,
      std::array<basis::OperatorBlocks<double>,3>& relative_component_matrices,
      basis::OperatorTypePN operator_type,
      int num_steps
    );
  // Construct coulomb operator in relative LSJT basis.
  //
  // These matrix elements are calculated for oscillator length
  // parameter b_rel = 2^(1/2) in the relative coordinate.  (See "Note
  // on oscillator length" at start of this header file.)
  //
  // Here the operator_type indicates whether this is a single species
  // operator for protons/neutrons or sees both types of nucleons.
  //
  // Makes use of spline integration.  An offset inner integration
  // point x0>0 is required to prevent the integrand from exploding.
  //
  // See notes on "internal representation of an operator in JT
  // scheme" in lsjt_operator.h for the general principles of how the
  // operators are represented.
  //
  // Arguments:
  //   operator_labels (input): tensorial properties of operator
  //   relative_space (input): target space
  //   relative_component_sectors (output): target sectors
  //   relative_component_matrices (output): target matrices
  //   operator_type (input): operator for protons, neutrons, or both
  //   num_steps (input): number of integration steps

  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
} // namespace

#endif

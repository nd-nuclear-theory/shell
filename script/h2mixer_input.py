"""h2mixer_input.py

    Provide simple standalone code for generating input file for
    h2mixer.

    Mark A. Caprio
    University of Notre Dame

    + 11/17/16 (mac): Created.

"""

import math
import os

# physical constants
k_mN_csqr = 938.92  # (m_N c^2)~938.92 MeV
k_hbar_c = 197.327  # (hbar c)~197.327 Mev fm

# parameter template
params = {
    # stored radial
    "Nmax_orb" : 20,
    "radial_me_filename_pattern" : "radial-me-ho-{}{}-Nmax20.dat",  # "{}{}" will be replaced by {"r1","r2","k1","k2"}
    "radial_olap_filename" : "radial-olap-ho-b1.414.dat",
    "orbitals_filename" : "orbitals-ho-Nmax20.dat",
    # stored input TBMEs
    "VNN_filename" : os.path.join(os.getenv("HOME"),"research/data/h2/run0164-ob-9/JISP16-ob-9-20.bin"),
    "VC_filename" : os.path.join(os.getenv("HOME"),"research/data/h2/run0164-ob-9/VC-ob-9-20.bin"),
    # scaling/transformation/basis parameters
    "hw" : 20,
    "target_truncation" : ("tb",6),
    "hw_int" : 20,
    "hw_c" : 20,
    "xform_enabled" : False,
    "xform_truncation" : ("ob",9),
    # Hamiltonian parameters
    "A" : 4,   # atomic mass number of nucleus (for kinematic operators)
    "a" : 20,  # coefficient on Ncm in Lawson term
    "hw_cm" : None,  # hw for Ncm in Lawson term; if None, defaults to "hw"
    "use_coulomb" : True,
    # output file format
    "h2_format" : 0  # h2 formats: 0, 15099
}

# 
# define-radial-operator r 1 test/radial-me-ho-r1-Nmax24.dat
# define-radial-operator r 2 test/radial-me-ho-r2-Nmax24.dat
# define-radial-operator k 1 test/radial-me-ho-k1-Nmax24.dat
# define-radial-operator k 2 test/radial-me-ho-k2-Nmax24.dat
# 
# define-operator-source Ursqr
# define-operator-source Vr1r2
# define-operator-source Uksqr
# define-operator-source Vk1k2
# 
# define-target Ursqr test/tbme-rsqr-tb-6-v0.dat
#   add-source Ursqr 1
# define-target Vr1r2 test/tbme-r1r2-tb-6-v0.dat
#  add-source Vr1r2 1
# define-target Uksqr test/tbme-ksqr-tb-6-v0.dat
#   add-source Uksqr 1
# define-target Vk1k2 test/tbme-k1k2-tb-6-v0.dat
#   add-source Vk1k2 1

def weight_max_string(truncation):
    """ Convert (rank,cutoff) to "wp wn wpp wnn wpn" string.

    >>> weight_max_string(("ob",4))
        "4 4 8 8 8"
    >>> weight_max_string(("tb",4))
        "4 4 4 4 4"
    """

    (code, N) = truncation
    if (code == "ob"):
        cutoffs = (N,2*N)
    elif (code == "tb"):
        cutoffs = (N,N)

    return "{0[0]} {0[0]} {0[1]} {0[1]} {0[1]}".format(cutoffs)

def oscillator_length(hw):
    """ Calculate oscillator length for given oscillator frequency.

    b(hw) = (hbar c)/[(m_N c^2) (hbar omega)]^(1/2)

    Arguments:
        hw (numeric): hbar omega in MeV

    Returns:
        (float): b in fm
    """
    
    return k_hbar_c/math.sqrt(k_mN_csqr*hw)
    

def run_script(params):
    """ Generate shell run script lines.

    Arguments:
        params (dict): parameter dictionary

    Returns:
        (list of str): input file lines
    """

    lines = []
    
    lines.append("orbital-gen --oscillator {Nmax_orb} {orbital_filename}".format(**params))

    return lines

def h2mixer_input(params):
    """ Generate input lines for h2mixer.

    Arguments:
        params (dict): parameter dictionary

    Returns:
        (list of str): input file lines
    """

    lines = []

    # initial comment
    lines.append("# h2mixer input generated by h2_input.py")
    lines.append("# given parameters:")
    lines.append("#   {}".format(params))
    lines.append("")

    # global mode definitions
    target_weight_max = weight_max_string(params["target_truncation"])
    lines.append("set-target-indexing {orbitals_filename} {target_weight_max}".format(target_weight_max=target_weight_max,**params))
    ## lines.append("set-target-indexing-oscillator {target_truncation[0]} {target_truncation[1]}".format(**params))
    lines.append("set-target-multipolarity 0 0 0")
    lines.append("set-output-format {h2_format}".format(**params))
    lines.append("set-mass {A}".format(**params))
    lines.append("")

    # radial operator inputs
    for operator_type in ["r","k"]:
        for power in [1,2]:
            radial_me_filename = params["radial_me_filename_pattern"].format(operator_type,power)
            lines.append("define-radial-operator {} {} {}".format(operator_type,power,radial_me_filename))
    lines.append("")
    
    # sources: identity and kinematic operators
    lines.append("define-source operator identity")
    lines.append("define-source operator Ursqr")
    lines.append("define-source operator Vr1r2")
    lines.append("define-source operator Uksqr")
    lines.append("define-source operator Vk1k2")
    lines.append("")

    # sources: VNN
    if (params["xform_enabled"]):
        # TODO
        xform_weight_max = weight_max_string(params["xform_truncation"])
        lines.append("define-source xform VNN {VNN_filename} {xform_weight_max} {radial_olap_filename}".format(xform_weight_max=xform_weight_max,**params))
    else:
        lines.append("define-source input VNN {VNN_filename}".format(**params))

    # sources: Coulomb
    if (params["use_coulomb"]):
        lines.append("define-source input VC {VC_filename}".format(**params))
    lines.append("")

    # extract Hamiltonian parameters for convenience
    A = params["A"]
    a = params["a"]
    hw = params["hw"]
    hw_c = params["hw_c"]
    hw_cm = params["hw_cm"]
    if (hw_cm is None):
        hw_cm = hw

    # target: Hamiltonian
    coef_Uksqr = (A-1)/(2*A)*hw+1/(2*A)*a*(hw/hw_cm)
    coef_Vk1k2 = -1/A*hw+1/A*a*(hw/hw_cm)
    coef_Ursqr = 1/(2*A)*a*(hw_cm/hw)
    coef_Vr1r2 = 1/A*a*(hw_cm/hw)
    coef_identity = -3/2*a
    lines.append("define-target tbme-H.dat")
    lines.append("  add-source Ursqr {:e}".format(coef_Ursqr))
    lines.append("  add-source Vr1r2 {:e}".format(coef_Vr1r2))
    lines.append("  add-source Uksqr {:e}".format(coef_Uksqr))
    lines.append("  add-source Vk1k2 {:e}".format(coef_Vk1k2))
    lines.append("  add-source identity {:e}".format(coef_identity))
    lines.append("  add-source VNN {}".format(1.))
    if (params["use_coulomb"]):
        coef_VC = math.sqrt(params["hw"]/params["hw_c"])
        lines.append("  add-source VC {:e}".format(coef_VC))

    # target: radius squared
    coef_Ursqr = (A-1)*(oscillator_length(hw)/A)**2
    coef_Vr1r2 = -2*(oscillator_length(hw)/A)**2
    lines.append("define-target tbme-rrel2.dat")
    lines.append("  add-source Ursqr {:e}".format(coef_Ursqr))
    lines.append("  add-source Vr1r2 {:e}".format(coef_Vr1r2))

    # target: NCM
    #
    # These are the "a" terms from the Hamiltonian, but without the "a".
    coef_Uksqr = 1/(2*A)*(hw/hw_cm)
    coef_Vk1k2 = 1/A*(hw/hw_cm)
    coef_Ursqr = 1/(2*A)*(hw_cm/hw)
    coef_Vr1r2 = 1/A*(hw_cm/hw)
    coef_identity = -3/2
    lines.append("define-target tbme-Ncm.dat")
    lines.append("  add-source Ursqr {:e}".format(coef_Ursqr))
    lines.append("  add-source Vr1r2 {:e}".format(coef_Vr1r2))
    lines.append("  add-source Uksqr {:e}".format(coef_Uksqr))
    lines.append("  add-source Vk1k2 {:e}".format(coef_Vk1k2))
    lines.append("  add-source identity {:e}".format(coef_identity))
    
    return lines

print("\n".join(h2mixer_input(params)))
